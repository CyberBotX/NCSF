using System.Buffers.Binary;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using CommunityToolkit.Diagnostics;
using CommunityToolkit.HighPerformance;

namespace NCSFCommon.NC;

/// <summary>
/// SDAT - SDAT (Sound Data).
/// </summary>
/// <remarks>
/// By Naram Qashat (CyberBotX) [cyberbotx@cyberbotx.com]
/// <para>
/// Uses data from
/// <see href="http://www.feshrine.net/hacking/doc/nds-sdat.html">Nintendo DS Nitro Composer (SDAT) Specification document</see>.
/// </para>
/// </remarks>
public class SDAT : NDSStandardHeader
{
	public override uint Magic { get; } = 0x0100FEFF;

	public override uint FileSize => this.Size;

	/// <summary>
	/// The signature of an SDAT, consisting of "SDAT" followed by the magic bytes.
	/// </summary>
	public static readonly ReadOnlyMemory<byte> Signature = new byte[]
	{
		0x53, 0x44, 0x41, 0x54, // "SDAT"
		0xFF, 0xFE, 0x00, 0x01 // Magic bytes
	};

	/// <summary>
	/// "FILE" as bytes.
	/// </summary>
	static readonly ReadOnlyMemory<byte> FILEHeader = "FILE"u8.ToArray();

	public override ushort HeaderSize { get; } = 0x40;

	ushort actualBlocks = 3;

	public override ushort Blocks => this.actualBlocks;

	/// <summary>
	/// The "filename" of the file.
	/// </summary>
	public string? Filename { get; set; }

	/// <summary>
	/// The offset of the SYMB section from the start of the file, will be unused if there is no SYMB section.
	/// </summary>
	public uint SYMBOffset { get; set; }

	/// <summary>
	/// The size of the SYMB section, copied from <see cref="SYMBSection" /> (and not padded to the next 4 byte boundary),
	/// will be unused if there is no SYMB section.
	/// </summary>
	public uint SYMBSize { get; set; }

	/// <summary>
	/// The offset of the INFO section from the start of the file.
	/// </summary>
	public uint INFOOffset { get; set; }

	/// <summary>
	/// The size of the INFO section, copied from <see cref="INFOSection" />.
	/// </summary>
	public uint INFOSize { get; set; }

	/// <summary>
	/// The offset of the FAT section from the start of the file.
	/// </summary>
	public uint FATOffset { get; set; }

	/// <summary>
	/// The size of the FAT section, copied from <see cref="FATSection" />.
	/// </summary>
	public uint FATSize { get; set; }

	/// <summary>
	/// The offset of the FILE section from the start of the file.
	/// </summary>
	public uint FILEOffset { get; set; }

	/// <summary>
	/// The size of the FILE section.
	/// </summary>
	public uint FILESize { get; set; }

	/// <summary>
	/// Not an actual count, but a fake value stored in the reserved section of an SDAT generated by tools utilizing this library
	/// to signify how many SDATs were used to compose this particular SDAT.
	/// </summary>
	public ushort Count { get; set; }

	/// <summary>
	/// The <see cref="NC.SYMBSection" />, if any, of this file.
	/// </summary>
	public SYMBSection? SYMBSection { get; private set; }

	/// <summary>
	/// The <see cref="NC.INFOSection" /> of this file.
	/// </summary>
	public INFOSection INFOSection { get; private set; } = new();

	/// <summary>
	/// The <see cref="NC.FATSection" /> of this file.
	/// </summary>
	public FATSection FATSection { get; private set; } = new();

	/// <summary>
	/// <see langword="true" /> if the <see cref="SYMBSection" /> needs to be cleaned up later, <see langword="false" /> otherwise.
	/// </summary>
	public bool SYMBSectionNeedsCleanup { get; set; }

	readonly List<SSEQ> sseqs = [];

	/// <summary>
	/// The <see cref="SSEQ" />s contained in this file.
	/// </summary>
	public ReadOnlySpan<SSEQ> SSEQs => this.sseqs.AsSpan();

	readonly List<SBNK> sbnks = [];

	/// <summary>
	/// The <see cref="SBNK" />s contained in this file.
	/// </summary>
	public ReadOnlySpan<SBNK> SBNKs => this.sbnks.AsSpan();

	readonly List<SWAR> swars = [];

	/// <summary>
	/// The <see cref="SWAR" />s contained in this file.
	/// </summary>
	public ReadOnlySpan<SWAR> SWARs => this.swars.AsSpan();

	/// <summary>
	/// Only used for playback, the <see cref="INFOEntryPLAYER" /> record for a requested SSEQ.
	/// Should be <see langword="null" /> in all other cases.
	/// </summary>
	public INFOEntryPLAYER? Player { get; private set; }

	/// <summary>
	/// The full file size.
	/// </summary>
	public uint Size { get; set; }

	/// <inheritdoc />
	/// <remarks>
	/// "SDAT" as bytes.
	/// </remarks>
	protected override byte[] ExpectedHeader() => [.. "SDAT"u8];

	/// <summary>
	/// Base method for reading the data for the <see cref="SDAT" />, shared by both versions of the Read method.
	/// </summary>
	/// <param name="filename">The filename to use for the <see cref="SDAT" />.</param>
	/// <param name="span">The <see cref="ReadOnlySpan{T}" /> to read from.</param>
	/// <exception cref="InvalidDataException">There were no SSEQ records.</exception>
	[MemberNotNull(nameof(SDAT.Filename))]
	void BaseRead(string filename, ReadOnlySpan<byte> span)
	{
		this.Filename = filename;

		// Read header.
		this.Read(span);
		this.SYMBOffset = BinaryPrimitives.ReadUInt32LittleEndian(span[0x10..]);
		this.SYMBSize = BinaryPrimitives.ReadUInt32LittleEndian(span[0x14..]);
		this.INFOOffset = BinaryPrimitives.ReadUInt32LittleEndian(span[0x18..]);
		this.INFOSize = BinaryPrimitives.ReadUInt32LittleEndian(span[0x1C..]);
		this.FATOffset = BinaryPrimitives.ReadUInt32LittleEndian(span[0x20..]);
		this.FATSize = BinaryPrimitives.ReadUInt32LittleEndian(span[0x24..]);
		this.Count = BinaryPrimitives.ReadUInt16LittleEndian(span[0x30..]);

		// Read SYMB (if it exists), INFO, and FAT sections.
		if (this.SYMBOffset != 0)
		{
			this.SYMBSection = new SYMBSection().Read(span[(int)this.SYMBOffset..]);
			this.actualBlocks = 4;
		}
		this.INFOSection.Read(span[(int)this.INFOOffset..]);
		this.FATSection.Read(span[(int)this.FATOffset..]);

		// Throw an exception if there were no SSEQ records.
		if (this.INFOSection.SEQRecord.Entries.Length == 0)
			ThrowHelper.ThrowInvalidDataException("No SSEQ records found in SDAT");
	}

	/// <summary>
	/// Reads the data for the <see cref="SDAT" />.
	/// </summary>
	/// <param name="filename">The filename to use for the <see cref="SDAT" />.</param>
	/// <param name="span">The <see cref="ReadOnlySpan{T}" /> to read from.</param>
	/// <param name="failOnMissingFiles">
	/// <see langword="true" /> (the default) if exceptions should be thrown on invalid files, <see langword="false" /> otherwise.
	/// </param>
	public void Read(string filename, ReadOnlySpan<byte> span, bool failOnMissingFiles = true)
	{
		this.BaseRead(filename, span);

		bool hasSYMBSection = this.SYMBOffset != 0;
		var seqINFOEntries = this.INFOSection.SEQRecord.Entries;

		// Read files.
		this.sseqs.Clear();
		var seqSYMBEntries = hasSYMBSection ? this.SYMBSection!.SEQRecord.Entries : default;
		var fatRecords = this.FATSection.Records;
		for (int i = 0, entries = seqINFOEntries.Length; i < entries; ++i)
		{
			var (Offset, Entry) = seqINFOEntries[i];
			if (Offset != 0 && Entry is not null)
			{
				uint fileID = Entry.FileID;
				string origName = $"SSEQ{fileID:X4}";
				string name = origName;
				if (hasSYMBSection)
				{
					origName = seqSYMBEntries[i].Name!;
					name = $"{i:X4} - {origName}";
				}
				Entry.OriginalFilename = origName;
				Entry.SDATNumber = this.Filename;
				SSEQ sseq = new(name, origName)
				{
					EntryNumber = i,
					Info = Entry
				};
				sseq.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
				Entry.SSEQ = sseq;
				this.sseqs.Add(sseq);
			}
		}
		this.sbnks.Clear();
		var bankSYMBEntries = hasSYMBSection ? this.SYMBSection!.BANKRecord.Entries : default;
		var bankINFOEntries = this.INFOSection.BANKRecord.Entries;
		for (int i = 0, entries = bankINFOEntries.Length; i < entries; ++i)
		{
			var (Offset, Entry) = bankINFOEntries[i];
			if (Offset != 0 && Entry is not null)
			{
				uint fileID = Entry.FileID;
				string origName = hasSYMBSection ? bankSYMBEntries[i].Name! : $"SBNK{fileID:X4}";
				Entry.OriginalFilename = origName;
				Entry.SDATNumber = this.Filename;
				SBNK sbnk = new(origName)
				{
					EntryNumber = i
				};
				sbnk.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
				Entry.SBNK = sbnk;
				this.sbnks.Add(sbnk);
			}
		}
		this.swars.Clear();
		var wavearcSYMBEntries = hasSYMBSection ? this.SYMBSection!.WAVEARCRecord.Entries : default;
		var wavearcINFOEntries = this.INFOSection.WAVEARCRecord.Entries;
		for (int i = 0, entries = wavearcINFOEntries.Length; i < entries; ++i)
		{
			var (Offset, Entry) = wavearcINFOEntries[i];
			if (Offset != 0 && Entry is not null)
			{
				uint fileID = Entry.FileID;
				string origName = hasSYMBSection ? wavearcSYMBEntries[i].Name! : $"SWAR{fileID:X4}";
				Entry.OriginalFilename = origName;
				Entry.SDATNumber = this.Filename;
				SWAR swar = new(origName)
				{
					EntryNumber = i
				};
				swar.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
				Entry.SWAR = swar;
				this.swars.Add(swar);
			}
		}
		var playerSYMBEntries = hasSYMBSection ? this.SYMBSection!.PLAYERRecord.Entries : default;
		var playerINFOEntries = this.INFOSection.PLAYERRecord.Entries;
		for (int i = 0, entries = playerINFOEntries.Length; i < entries; ++i)
		{
			var (Offset, Entry) = playerINFOEntries[i];
			if (Offset != 0 && Entry is not null)
			{
				Entry.OriginalFilename = hasSYMBSection ? playerSYMBEntries[i].Name! : $"PLAYER{i:X2}";
				Entry.SDATNumber = this.Filename;
			}
		}
	}

	/// <summary>
	/// Reads the data for the <see cref="SDAT" /> for a specific SSEQ only.
	/// </summary>
	/// <param name="filename">The filename to use for the <see cref="SDAT" />.</param>
	/// <param name="span">The <see cref="ReadOnlySpan{T}" /> to read from.</param>
	/// <param name="sseqToLoad">The number of the SSEQ record to load.</param>
	/// <param name="failOnMissingFiles">
	/// <see langword="true" /> (the default) if exceptions should be thrown on invalid files, <see langword="false" /> otherwise.
	/// </param>
	public void Read(string filename, ReadOnlySpan<byte> span, uint sseqToLoad, bool failOnMissingFiles = true)
	{
		this.BaseRead(filename, span);

		bool hasSYMBSection = this.SYMBOffset != 0;
		var seqINFOEntries = this.INFOSection.SEQRecord.Entries;

		Guard.IsBetweenOrEqualTo(sseqToLoad, 0, seqINFOEntries.Length);

		// Read SSEQ.
		this.sseqs.Clear();
		var seqSYMBEntries = hasSYMBSection ? this.SYMBSection!.SEQRecord.Entries : default;
		var fatRecords = this.FATSection.Records;
		var (SEQOffset, SEQEntry) = seqINFOEntries[(int)sseqToLoad];
		if (SEQOffset == 0 || SEQEntry is null)
			ThrowHelper.ThrowInvalidDataException("There is no valid SSEQ for the given SSEQ number.");
		uint fileID = SEQEntry.FileID;
		string origName = $"SSEQ{fileID:X4}";
		string name = origName;
		if (hasSYMBSection)
		{
			origName = seqSYMBEntries[(int)sseqToLoad].Name!;
			name = $"{sseqToLoad:X4} - {origName}";
		}
		SEQEntry.OriginalFilename = origName;
		SEQEntry.SDATNumber = this.Filename;
		SSEQ sseq = new(name, origName)
		{
			EntryNumber = (int)sseqToLoad,
			Info = SEQEntry
		};
		sseq.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
		SEQEntry.SSEQ = sseq;
		this.sseqs.Add(sseq);

		// Read SBNK for this SSEQ.
		this.sbnks.Clear();
		ushort bankID = SEQEntry.Bank;
		var (BANKOffset, BANKEntry) = this.INFOSection.BANKRecord.Entries[bankID];
		if (BANKOffset == 0 || BANKEntry is null)
			ThrowHelper.ThrowInvalidDataException("The requested SSEQ is asking for an invalid SBNK.");
		fileID = BANKEntry.FileID;
		origName = hasSYMBSection ? this.SYMBSection!.BANKRecord.Entries[bankID].Name! : $"SBNK{fileID:X4}";
		BANKEntry.OriginalFilename = origName;
		BANKEntry.SDATNumber = this.Filename;
		SBNK sbnk = new(origName)
		{
			EntryNumber = bankID,
			Info = BANKEntry
		};
		sbnk.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
		BANKEntry.SBNK = sbnk;
		this.sbnks.Add(sbnk);

		// Read SWARs for this SBNK.
		this.swars.Clear();
		for (int i = 0; i < 4; ++i)
		{
			ushort waveArcID = BANKEntry.WaveArchives[i];
			if (waveArcID != 0xFFFF)
			{
				var (WAVEARCEOffset, WAVEARCEntry) = this.INFOSection.WAVEARCRecord.Entries[waveArcID];
				if (WAVEARCEOffset == 0 || WAVEARCEntry is null)
					ThrowHelper.ThrowInvalidDataException("The requested SBNK is asking for an invalid SWAR.");
				fileID = WAVEARCEntry.FileID;
				origName = hasSYMBSection ? this.SYMBSection!.WAVEARCRecord.Entries[waveArcID].Name! : $"SWAR{fileID:X4}";
				WAVEARCEntry.OriginalFilename = origName;
				WAVEARCEntry.SDATNumber = this.Filename;
				SWAR swar = new(origName)
				{
					EntryNumber = waveArcID
				};
				swar.Read(span[(int)fatRecords[(int)fileID].Offset..], failOnMissingFiles);
				WAVEARCEntry.SWAR = swar;
				this.swars.Add(swar);
			}
		}

		// Get the PLAYER for this SSEQ, if it exists.
		if (this.INFOSection.PLAYERRecord.Entries.Length != 0)
			this.Player = this.INFOSection.PLAYERRecord.Entries[SEQEntry.Player].Entry;
		if (this.Player is not null && this.Player.ChannelMask == 0)
			this.Player.ChannelMask = 0xFFFF;
	}

	/// <summary>
	/// Writes the data for the <see cref="SDAT" />.
	/// </summary>
	/// <param name="span">The <see cref="Span{T}" /> to write to.</param>
	public override void Write(Span<byte> span)
	{
		// Write header.
		base.Write(span);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x10..], this.SYMBOffset);
		uint symbSizeMulOf4 = (uint)((this.SYMBSize + 3) & ~0x03);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x14..], symbSizeMulOf4);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x18..], this.INFOOffset);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x1C..], this.INFOSize);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x20..], this.FATOffset);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x24..], this.FATSize);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x28..], this.FILEOffset);
		BinaryPrimitives.WriteUInt32LittleEndian(span[0x2C..], this.FILESize);
		// Normally the reserved section contains 16 bytes of 0s, but for the purposes of
		// detecting if this SDAT was made from more than 1 SDAT or not, the
		// first 2 bytes will store the number of SDATs that this SDAT is made of.
		BinaryPrimitives.WriteUInt16LittleEndian(span[0x30..], this.Count);
		// Next line write the remaining 14 bytes of 0s for the reserved section.
		span[0x32..0x40].Clear();

		// Write SYMB (if it exists), INFO, and FAT sections.
		uint pos = 0x40;
		this.SYMBSection?.Write(span[(int)pos..]);
		pos += symbSizeMulOf4;
		this.INFOSection.Write(span[(int)pos..]);
		pos += this.INFOSize;
		this.FATSection.Write(span[(int)pos..]);
		pos += this.FATSize;

		// Write FILE section header.
		SDAT.FILEHeader.Span.CopyTo(span[(int)pos..]);
		BinaryPrimitives.WriteUInt32LittleEndian(span[(int)(pos + 0x04)..], this.FILESize);
		BinaryPrimitives.WriteUInt32LittleEndian(span[(int)(pos + 0x08)..], (uint)this.FATSection.Records.Length);
		// This writes the reserved 32-bit integer 0.
		span.Slice((int)(pos + 0x0C), 4).Clear();

		// Write files.
		pos += 0x10;
		foreach (var (_, Entry) in this.INFOSection.SEQRecord.Entries)
		{
			Entry?.SSEQ?.Write(span[(int)pos..]);
			pos += Entry?.SSEQ?.Size ?? 0;
		}
		foreach (var (_, Entry) in this.INFOSection.BANKRecord.Entries)
		{
			Entry?.SBNK?.Write(span[(int)pos..]);
			pos += Entry?.SBNK?.Size ?? 0;
		}
		foreach (var (_, Entry) in this.INFOSection.WAVEARCRecord.Entries)
		{
			Entry?.SWAR?.Write(span[(int)pos..]);
			pos += Entry?.SWAR?.Size ?? 0;
		}
	}

	/// <summary>
	/// Appends two SDATs to each other.
	/// </summary>
	/// <remarks>
	/// This will not make any changes to the offsets of these records, that is expected to be corrected in a later step.
	/// </remarks>
	/// <param name="sdat1">The first <see cref="SDAT" />.</param>
	/// <param name="sdat2">The second <see cref="SDAT" />.</param>
	/// <returns>The combined <see cref="SDAT" />.</returns>
	public static SDAT operator+(SDAT sdat1, SDAT sdat2)
	{
		SDAT newSDAT = new();

		uint sdat1SEQCount = (uint)sdat1.INFOSection.SEQRecord.Entries.Length;
		uint sdat1BANKCount = (uint)sdat1.INFOSection.BANKRecord.Entries.Length;
		uint sdat1WAVEARCCount = (uint)sdat1.INFOSection.WAVEARCRecord.Entries.Length;
		uint sdat1PLAYERCount = (uint)sdat1.INFOSection.PLAYERRecord.Entries.Length;

		int newSEQcount = (int)sdat1SEQCount + sdat2.INFOSection.SEQRecord.Entries.Length;
		int newBANKcount = (int)sdat1BANKCount + sdat2.INFOSection.BANKRecord.Entries.Length;
		int newWAVEARCcount = (int)sdat1WAVEARCCount + sdat2.INFOSection.WAVEARCRecord.Entries.Length;
		int newPLAYERcount = (int)sdat1PLAYERCount + sdat2.INFOSection.PLAYERRecord.Entries.Length;

		// First merge the SYMB sections, as long as one of the SDATs had one.
		if (sdat1.SYMBSection is not null || sdat2.SYMBSection is not null)
		{
			newSDAT.SYMBSection = sdat1.SYMBSection + sdat2.SYMBSection;

			// This is to make sure that we have enough entries in the symbol section's records,
			// in case one of the SDATs had no symbol section.
			newSDAT.SYMBSection.SEQRecord.ExpandNumberOfEntries((uint)newSEQcount);
			newSDAT.SYMBSection.BANKRecord.ExpandNumberOfEntries((uint)newBANKcount);
			newSDAT.SYMBSection.WAVEARCRecord.ExpandNumberOfEntries((uint)newWAVEARCcount);
			newSDAT.SYMBSection.PLAYERRecord.ExpandNumberOfEntries((uint)newPLAYERcount);

			newSDAT.SYMBSectionNeedsCleanup = true;

			newSDAT.SYMBOffset = 0x40;
		}

		// Next merge the INFO sections.
		newSDAT.INFOSection = sdat1.INFOSection + sdat2.INFOSection;

		// The next 3 blocks will shift the values from the second SDAT's records so they line up with the combined SDAT.

		newSDAT.INFOSection.SEQRecord.ExpandNumberOfEntries((uint)newSEQcount);
		var seqINFOEntries = newSDAT.INFOSection.SEQRecord.Entries;
		for (uint i = sdat1SEQCount; i < newSEQcount; ++i)
		{
			var (_, Entry) = seqINFOEntries[(int)i];
			if (Entry is not null)
			{
				Entry.Bank += (ushort)sdat1BANKCount;
				Entry.Player += (byte)sdat1PLAYERCount;
				if (Entry.SSEQ is not null)
					Entry.SSEQ.EntryNumber = (int)i;
			}
		}

		newSDAT.INFOSection.BANKRecord.ExpandNumberOfEntries((uint)newBANKcount);
		var bankINFOEntries = newSDAT.INFOSection.BANKRecord.Entries;
		for (uint i = sdat1BANKCount; i < newBANKcount; ++i)
		{
			var (_, Entry) = bankINFOEntries[(int)i];
			if (Entry is not null)
			{
				var waveArchives = Entry.WaveArchives;
				for (int j = 0; j < 4; ++j)
					if (waveArchives[j] != ushort.MaxValue)
						Entry.ReplaceWaveArchive(j, (ushort)(waveArchives[j] + sdat1WAVEARCCount));
				if (Entry.SBNK is not null)
					Entry.SBNK.EntryNumber = (int)i;
			}
		}

		newSDAT.INFOSection.WAVEARCRecord.ExpandNumberOfEntries((uint)newWAVEARCcount);
		var wavearcINFOEntries = newSDAT.INFOSection.WAVEARCRecord.Entries;
		for (uint i = sdat1WAVEARCCount; i < newWAVEARCcount; ++i)
		{
			var (_, Entry) = wavearcINFOEntries[(int)i];
			if (Entry?.SWAR is not null)
				Entry.SWAR.EntryNumber = (int)i;
		}

		newSDAT.INFOSection.PLAYERRecord.ExpandNumberOfEntries((uint)newPLAYERcount);

		// Next merge the FAT sections.
		newSDAT.FATSection = sdat1.FATSection + sdat2.FATSection;

		// Add all the files from both SDATs together.
		newSDAT.sseqs.AddRange(sdat1.sseqs);
		newSDAT.sseqs.AddRange(sdat2.sseqs);
		newSDAT.sbnks.AddRange(sdat1.sbnks);
		newSDAT.sbnks.AddRange(sdat2.sbnks);
		newSDAT.swars.AddRange(sdat1.swars);
		newSDAT.swars.AddRange(sdat2.swars);

		// Increase the internal count by 1 more than the first SDAT's count.
		newSDAT.Count = (ushort)(sdat1.Count + 1);

		return newSDAT;
	}

	/// <summary>
	/// Converts a potentially duplicated number into a non-duplicated one.
	/// </summary>
	/// <param name="orig">The original number.</param>
	/// <param name="duplicates">The dictionary containing all the duplicates for the keys.</param>
	/// <returns>The non-duplicated number.</returns>
	static uint GetNonDuplicateNumber(uint orig, Dictionary<uint, List<uint>> duplicates)
	{
		// If the original number is a key, then it is not a duplicate, so just return the original number.
		if (duplicates.ContainsKey(orig))
			return orig;
		// Otherwise, try to find the first item in the dictionary, if any, that contains the original number.
		var duplicate = duplicates.FirstOrDefault(kvp => kvp.Value.Contains(orig));
		// If the original number was found in one of the items, return the item's key (the non-duplicated number),
		// otherwise just return the original number.
		return duplicate.Value is not null ? duplicate.Key : orig;
	}

	/// <summary>
	/// Outputs a list of names from an INFO record to the console.
	/// </summary>
	/// <typeparam name="T">The <see cref="INFOEntry" /> type that is being output.</typeparam>
	/// <param name="list">A list containing the indices from the INFO record being output.</param>
	/// <param name="nameSource">The collection of entries from the INFO record that will be used for the names to output.</param>
	/// <param name="multipleSDATs">
	/// <see langword="true" /> if the SDAT number should be included in the name, <see langword="false" /> otherwise.
	/// </param>
	/// <param name="outputPrefix">The prefix before the start of the output, defaults to a single space.</param>
	/// <param name="columnWidth">The column width to limit output length to, defaults to 80.</param>
	static void OutputList<T>(List<uint> list, ReadOnlySpan<(uint Offset, T? Entry)> nameSource, bool multipleSDATs,
		string outputPrefix = " ", int columnWidth = 80) where T : INFOEntry
	{
		StringBuilder sb = new(outputPrefix);
		foreach (uint item in list)
		{
			string keep = nameSource[(int)item].Entry!.FullFilename(multipleSDATs);
			if (sb.Length + keep.Length > columnWidth)
			{
				Console.WriteLine($"{sb}");
				_ = sb.Clear();
				_ = sb.Append("   ");
			}
			_ = sb.Append($" {keep},");
		}
		if (sb.Length != 0)
			Console.WriteLine($"{sb}"[0..^1]);
	}

	/// <summary>
	/// Outputs a dictionary of lists of names from an INFO record to the console.
	/// </summary>
	/// <typeparam name="T">The <see cref="INFOEntry" /> type that is being output.</typeparam>
	/// <param name="dictionary">A dictionary containing the indices from the INFO record being output.</param>
	/// <param name="nameSource">The collection of entries from the INFO record that will be used for the names to output.</param>
	/// <param name="multipleSDATs">
	/// <see langword="true" /> if the SDAT number should be included in the name, <see langword="false" /> otherwise.
	/// </param>
	/// <param name="columnWidth">The column width to limit output length to, defaults to 80.</param>
	static void OutputDictionary<T>(Dictionary<uint, List<uint>> dictionary, ReadOnlySpan<(uint Offset, T? Entry)> nameSource,
		bool multipleSDATs, int columnWidth = 80) where T : INFOEntry
	{
		foreach (var kvp in dictionary)
			SDAT.OutputList(kvp.Value, nameSource, multipleSDATs, $"  {nameSource[(int)kvp.Key].Entry!.FullFilename(multipleSDATs)}:",
				columnWidth);
	}

	/// <summary>
	/// Strips the excluded and duplicate files from the <see cref="SDAT" />.
	/// </summary>
	/// <param name="includesAndExcludes">The list of items to include and exclude.</param>
	/// <param name="verbose">
	/// <see langword="true" /> if what is being done should be printed to the console, <see langword="false" /> otherwise.
	/// </param>
	/// <param name="removeExcluded">
	/// <see langword="true" /> if excluded SSEQs should actually be removed, <see langword="false" /> otherwise.
	/// </param>
	public void Strip(List<Common.KeepInfo> includesAndExcludes, bool verbose, bool removeExcluded = true)
	{
		// Search for duplicate PLAYERs.
		Dictionary<uint, List<uint>> duplicatePLAYERs = [];

		var playerINFOEntries = this.INFOSection.PLAYERRecord.Entries;
		for (uint i = 0, entries = (uint)playerINFOEntries.Length; i < entries; ++i)
		{
			var (iOffset, iEntry) = playerINFOEntries[(int)i];
			// Skip empty offsets and if we already added as a duplicate of another PLAYER.
			if (iOffset != 0 && iEntry is not null && !duplicatePLAYERs.Any(kvp => kvp.Value.Contains(i)))
			{
				List<uint> duplicates = [];
				for (uint j = i + 1; j < entries; ++j)
				{
					var (jOffset, jEntry) = playerINFOEntries[(int)j];
					// Skip empty offsets and if the PLAYERs are not the same.
					if (jOffset != 0 && jEntry is not null && iEntry == jEntry)
						duplicates.Add(j);
				}
				if (duplicates.Count != 0)
					duplicatePLAYERs[i] = duplicates;
			}
		}

		// Search for duplicate SWARs.
		Dictionary<uint, List<uint>> duplicateSWARs = [];

		var wavearcINFOEntries = this.INFOSection.WAVEARCRecord.Entries;
		for (uint i = 0, entries = (uint)wavearcINFOEntries.Length; i < entries; ++i)
		{
			var (iOffset, iEntry) = wavearcINFOEntries[(int)i];
			// Skip empty offsets and if we already added as a duplicate of another SWAR.
			if (iOffset != 0 && iEntry is not null && !duplicateSWARs.Any(kvp => kvp.Value.Contains(i)))
			{
				List<uint> duplicates = [];
				for (uint j = i + 1; j < entries; ++j)
				{
					var (jOffset, jEntry) = wavearcINFOEntries[(int)j];
					// Skip empty offsets and if the WAVEARCs are not the same.
					if (jOffset != 0 && jEntry is not null && iEntry == jEntry)
						duplicates.Add(j);
				}
				if (duplicates.Count != 0)
					duplicateSWARs[i] = duplicates;
			}
		}

		// Search for duplicate SBNKs.
		Dictionary<uint, List<uint>> duplicateSBNKs = [];

		var bankINFOEntries = this.INFOSection.BANKRecord.Entries;
		for (uint i = 0, entries = (uint)bankINFOEntries.Length; i < entries; ++i)
		{
			var (iOffset, iEntry) = bankINFOEntries[(int)i];
			// Skip empty offsets and if we already added as a duplicate of another SBNK.
			if (iOffset != 0 && iEntry is not null && !duplicateSBNKs.Any(kvp => kvp.Value.Contains(i)))
			{
				ushort[] iWaveArchives = [.. Enumerable.Repeat(ushort.MaxValue, 4)];
				var waveArchives = iEntry.WaveArchives;
				for (int k = 0; k < 4; ++k)
				{
					ushort waveArchive = waveArchives[k];
					if (waveArchive != ushort.MaxValue)
						iWaveArchives[k] = (ushort)SDAT.GetNonDuplicateNumber(waveArchive, duplicateSWARs);
				}
				List<uint> duplicates = [];
				for (uint j = i + 1; j < entries; ++j)
				{
					var (jOffset, jEntry) = bankINFOEntries[(int)j];
					// Skip empty offsets and if the file data of the BANKs are not the same.
					if (jOffset != 0 && jEntry is not null && iEntry.FileEquals(jEntry))
					{
						ushort[] jWaveArchives = [.. Enumerable.Repeat(ushort.MaxValue, 4)];
						waveArchives = jEntry.WaveArchives;
						for (int k = 0; k < 4; ++k)
						{
							ushort waveArchive = waveArchives[k];
							if (waveArchive != ushort.MaxValue)
								jWaveArchives[k] = (ushort)SDAT.GetNonDuplicateNumber(waveArchive, duplicateSWARs);
						}
						if (iWaveArchives.AsSpan().SequenceEqual(jWaveArchives))
							duplicates.Add(j);
					}
				}
				if (duplicates.Count != 0)
					duplicateSBNKs[i] = duplicates;
			}
		}

		// Search for duplicate SSEQs, as well as ones that the user requested to exclude.
		Dictionary<uint, List<uint>> duplicateSSEQs = [];
		List<uint> excludedSSEQs = [];

		var seqINFOEntries = this.INFOSection.SEQRecord.Entries;
		for (uint i = 0, entries = (uint)seqINFOEntries.Length; i < entries; ++i)
		{
			var (iOffset, iEntry) = seqINFOEntries[(int)i];
			// Skip empty offsets and if we already excluded.
			if (iOffset != 0 && iEntry is not null && !excludedSSEQs.Contains(i))
			{
				var alreadyFound = duplicateSSEQs.FirstOrDefault(kvp => kvp.Value.Contains(i));
				if (Common.IncludeFilename(iEntry.OriginalFilename, iEntry.SDATNumber, includesAndExcludes) == Common.KeepType.Exclude)
				{
					excludedSSEQs.Add(i);
					if (alreadyFound.Value is not null)
						_ = alreadyFound.Value.Remove(i);
					continue;
				}

				// Skip if we already added as a duplicate of another SSEQ.
				if (alreadyFound.Value is null)
				{
					uint iNonDuplicateBank = SDAT.GetNonDuplicateNumber(iEntry.Bank, duplicateSBNKs);
					List<uint> duplicates = [];
					for (uint j = i + 1; j < entries; ++j)
					{
						var (jOffset, jEntry) = seqINFOEntries[(int)j];
						// Skip empty offsets and if the file data of the SEQs are not the same.
						if (jOffset != 0 && jEntry is not null && iEntry.FileEquals(jEntry))
						{
							uint jNonDuplicateBank = SDAT.GetNonDuplicateNumber(jEntry.Bank, duplicateSBNKs);
							if (iNonDuplicateBank == jNonDuplicateBank)
								duplicates.Add(j);
						}
					}
					if (duplicates.Count != 0)
						duplicateSSEQs[i] = duplicates;
				}
			}
		}

		// Determine which SSEQs to keep.
		List<uint> SSEQsToKeep = [];

		for (uint i = 0, entries = (uint)seqINFOEntries.Length; i < entries; ++i)
		{
			var (iOffset, iEntry) = seqINFOEntries[(int)i];
			// Skip empty offsets, if this is a duplicate, or if the user requested it be excluded.
			if (iOffset != 0 && iEntry is not null && !duplicateSSEQs.Any(kvp => kvp.Value.Contains(i)) &&
				(!removeExcluded || !excludedSSEQs.Contains(i)))
				SSEQsToKeep.Add(i);
		}

		// Determine which SBNKs to keep and are being used by the SSEQs we are keeping.
		List<uint> SBNKsToKeep = [];

		foreach (uint SSEQToKeep in SSEQsToKeep)
		{
			uint nonDuplicateBank = SDAT.GetNonDuplicateNumber(seqINFOEntries[(int)SSEQToKeep].Entry!.Bank, duplicateSBNKs);
			if (!SBNKsToKeep.Contains(nonDuplicateBank))
				SBNKsToKeep.Add(nonDuplicateBank);
		}

		// Sort the list of SBNKs to keep.
		SBNKsToKeep.Sort();

		// Determine which SWARs to keep and are being used by the SBNKs we are keeping.
		List<uint> SWARsToKeep = [];

		foreach (uint SBNKToKeep in SBNKsToKeep)
			foreach (ushort waveArchive in bankINFOEntries[(int)SBNKToKeep].Entry!.WaveArchives)
				if (waveArchive != ushort.MaxValue)
				{
					uint nonDuplicateWaveArchive = SDAT.GetNonDuplicateNumber(waveArchive, duplicateSWARs);
					if (!SWARsToKeep.Contains(nonDuplicateWaveArchive))
						SWARsToKeep.Add(nonDuplicateWaveArchive);
				}

		// Sort the list of SWARs to keep.
		SWARsToKeep.Sort();

		// Determine which PLAYERs to keep and are being used by SSEQs we are keeping.
		List<uint> PLAYERsToKeep = [];

		uint numPlayers = (uint)playerINFOEntries.Length;
		foreach (uint SSEQToKeep in SSEQsToKeep)
		{
			uint nonDuplicatePlayer = SDAT.GetNonDuplicateNumber(seqINFOEntries[(int)SSEQToKeep].Entry!.Player, duplicatePLAYERs);
			if (!PLAYERsToKeep.Contains(nonDuplicatePlayer) && nonDuplicatePlayer < numPlayers)
				PLAYERsToKeep.Add(nonDuplicatePlayer);
		}

		// Sort the list of PLAYERs to keep.
		PLAYERsToKeep.Sort();

		// If verbosity is turned on, output which files will be kept and which are being removed as duplicates.
		if (verbose)
		{
			if (removeExcluded && excludedSSEQs.Count != 0)
			{
				Console.WriteLine($"The following SSEQ{(excludedSSEQs.Count == 1 ? "" : "s")} were excluded by request:");
				SDAT.OutputList(excludedSSEQs, seqINFOEntries, this.Count > 1);
				Console.WriteLine();
			}

			if (duplicateSSEQs.Count != 0)
			{
				Console.WriteLine($"The following SSEQ{(duplicateSSEQs.Count == 1 ? "" : "s")} had duplicates, the duplicates will be removed:");
				SDAT.OutputDictionary(duplicateSSEQs, seqINFOEntries, this.Count > 1);
				Console.WriteLine();
			}

			if (duplicateSBNKs.Count != 0)
			{
				Console.WriteLine($"The following SBNK{(duplicateSBNKs.Count == 1 ? "" : "s")} had duplicates, the duplicates will be removed:");
				SDAT.OutputDictionary(duplicateSBNKs, bankINFOEntries, this.Count > 1);
				Console.WriteLine();
			}

			if (duplicateSWARs.Count != 0)
			{
				Console.WriteLine($"The following SWAR{(duplicateSWARs.Count == 1 ? "" : "s")} had duplicates, the duplicates will be removed:");
				SDAT.OutputDictionary(duplicateSWARs, wavearcINFOEntries, this.Count > 1);
				Console.WriteLine();
			}

			if (duplicatePLAYERs.Count != 0)
			{
				Console.WriteLine($"The following PLAYER{(duplicatePLAYERs.Count == 1 ? "" : "s")} had duplicates, the duplicates will be removed:");
				SDAT.OutputDictionary(duplicatePLAYERs, playerINFOEntries, this.Count > 1);
				Console.WriteLine();
			}
		}

		// Figure out where the remaining SBNKs will be once moved.
		Dictionary<uint, uint> SBNKMove = [];

		for (uint i = 0, num = (uint)SBNKsToKeep.Count; i < num; ++i)
			SBNKMove[SBNKsToKeep[(int)i]] = i;

		// Figure out where the remaining SWARs will be once moved.
		Dictionary<uint, uint> SWARMove = [];

		for (uint i = 0, num = (uint)SWARsToKeep.Count; i < num; ++i)
			SWARMove[SWARsToKeep[(int)i]] = i;

		// Figure out where the remaining PLAYERs will be once moved.
		Dictionary<uint, uint> PLAYERMove = [];

		for (uint i = 0, num = (uint)PLAYERsToKeep.Count; i < num; ++i)
			PLAYERMove[PLAYERsToKeep[(int)i]] = i;

		// Remove all unused items (or rather, save only used items).
		bool hasSYMBSection = this.SYMBSection is not null;
		SYMBSection newSYMBSection = new();
		if (hasSYMBSection)
		{
			newSYMBSection.SEQRecord.SetNumberOfEntries((uint)SSEQsToKeep.Count);
			newSYMBSection.BANKRecord.SetNumberOfEntries((uint)SBNKsToKeep.Count);
			newSYMBSection.WAVEARCRecord.SetNumberOfEntries((uint)SWARsToKeep.Count);
			newSYMBSection.PLAYERRecord.SetNumberOfEntries((uint)PLAYERsToKeep.Count);
		}

		INFOSection newINFOSection = new();

		newINFOSection.SEQRecord.SetNumberOfEntries((uint)SSEQsToKeep.Count);
		newINFOSection.BANKRecord.SetNumberOfEntries((uint)SBNKsToKeep.Count);
		newINFOSection.WAVEARCRecord.SetNumberOfEntries((uint)SWARsToKeep.Count);
		newINFOSection.PLAYERRecord.SetNumberOfEntries((uint)PLAYERsToKeep.Count);

		List<SSEQ> newSSEQs = [];
		ushort fileID = 0;
		var seqSYMBEntries = hasSYMBSection ? this.SYMBSection!.SEQRecord.Entries : default;
		for (uint i = 0, num = (uint)SSEQsToKeep.Count; i < num; ++i)
		{
			if (hasSYMBSection)
				newSYMBSection.SEQRecord.SetEntry(i, seqSYMBEntries[(int)SSEQsToKeep[(int)i]]);

			var (Offset, Entry) = seqINFOEntries[(int)SSEQsToKeep[(int)i]];
			INFOEntrySEQ newSEQEntry = new(Entry!)
			{
				FileID = fileID++
			};
			newSEQEntry.Bank = (ushort)SBNKMove[SDAT.GetNonDuplicateNumber(newSEQEntry.Bank, duplicateSBNKs)];
			newSEQEntry.Player = (byte)PLAYERMove[SDAT.GetNonDuplicateNumber(newSEQEntry.Player, duplicatePLAYERs)];
			newSEQEntry.SSEQ!.EntryNumber = (int)i;
			newSSEQs.Add(newSEQEntry.SSEQ);
			newINFOSection.SEQRecord.SetEntry(i, (Offset, newSEQEntry));
		}

		List<SBNK> newSBNKs = [];
		var bankSYMBEntries = hasSYMBSection ? this.SYMBSection!.BANKRecord.Entries : default;
		for (uint i = 0, num = (uint)SBNKsToKeep.Count; i < num; ++i)
		{
			if (hasSYMBSection)
				newSYMBSection.BANKRecord.SetEntry(i, bankSYMBEntries[(int)SBNKsToKeep[(int)i]]);

			var (Offset, Entry) = bankINFOEntries[(int)SBNKsToKeep[(int)i]];
			INFOEntryBANK newBANKEntry = new(Entry!)
			{
				FileID = fileID++
			};
			var waveArchives = newBANKEntry.WaveArchives;
			for (int j = 0; j < 4; ++j)
			{
				ushort waveArc = waveArchives[j];
				if (waveArc != ushort.MaxValue)
					newBANKEntry.ReplaceWaveArchive(j, (ushort)SWARMove[SDAT.GetNonDuplicateNumber(waveArc, duplicateSWARs)]);
			}
			newBANKEntry.SBNK!.EntryNumber = (int)i;
			newSBNKs.Add(newBANKEntry.SBNK);
			newINFOSection.BANKRecord.SetEntry(i, (Offset, newBANKEntry));
		}

		List<SWAR> newSWARs = [];
		var wavearcSYMBEntries = hasSYMBSection ? this.SYMBSection!.WAVEARCRecord.Entries : default;
		for (uint i = 0, num = (uint)SWARsToKeep.Count; i < num; ++i)
		{
			if (hasSYMBSection)
				newSYMBSection.WAVEARCRecord.SetEntry(i, wavearcSYMBEntries[(int)SWARsToKeep[(int)i]]);

			var (Offset, Entry) = wavearcINFOEntries[(int)SWARsToKeep[(int)i]];
			INFOEntryWAVEARC newWAVEARCEntry = new(Entry!)
			{
				FileID = fileID++
			};
			newWAVEARCEntry.SWAR!.EntryNumber = (int)i;
			newSWARs.Add(newWAVEARCEntry.SWAR);
			newINFOSection.WAVEARCRecord.SetEntry(i, (Offset, newWAVEARCEntry));
		}

		var playerSYMBEntries = hasSYMBSection ? this.SYMBSection!.PLAYERRecord.Entries : default;
		for (uint i = 0, num = (uint)PLAYERsToKeep.Count; i < num; ++i)
		{
			if (hasSYMBSection)
				newSYMBSection.PLAYERRecord.SetEntry(i, playerSYMBEntries[(int)PLAYERsToKeep[(int)i]]);

			var (Offset, Entry) = playerINFOEntries[(int)PLAYERsToKeep[(int)i]];
			newINFOSection.PLAYERRecord.SetEntry(i, (Offset, new(Entry!)));
		}

		if (hasSYMBSection)
			this.SYMBSection = newSYMBSection;
		this.INFOSection = newINFOSection;

		this.sseqs.Clear();
		this.sseqs.AddRange(newSSEQs);
		this.sbnks.Clear();
		this.sbnks.AddRange(newSBNKs);
		this.swars.Clear();
		this.swars.AddRange(newSWARs);

		FATSection newFATSection = new();
		newFATSection.SetNumberOfRecords(fileID);
		this.FATSection = newFATSection;

		// If one of the files that was merged into this one had no SYMB section, then we need to fill in some dummy data for those entries.
		if (this.SYMBSectionNeedsCleanup)
		{
			seqSYMBEntries = this.SYMBSection!.SEQRecord.Entries;
			seqINFOEntries = this.INFOSection.SEQRecord.Entries;
			for (uint i = 0, num = (uint)SSEQsToKeep.Count; i < num; ++i)
			{
				var (SYMBOffset, SYMBEntry) = seqSYMBEntries[(int)i];
				var (INFOOffset, INFOEntry) = seqINFOEntries[(int)i];
				if (string.IsNullOrEmpty(SYMBEntry))
					this.SYMBSection.SEQRecord.SetEntry(i, (SYMBOffset, SYMBEntry = $"SSEQ{INFOEntry!.FileID:X4}"));
				var sseq = INFOEntry!.SSEQ!;
				sseq.OriginalFilename = SYMBEntry;
				if (!SYMBEntry.StartsWith("SSEQ"))
					sseq.Filename = $"{i:X4} - {SYMBEntry}";
			}
			bankSYMBEntries = this.SYMBSection!.BANKRecord.Entries;
			bankINFOEntries = this.INFOSection.BANKRecord.Entries;
			for (uint i = 0, num = (uint)SBNKsToKeep.Count; i < num; ++i)
			{
				var (SYMBOffset, SYMBEntry) = bankSYMBEntries[(int)i];
				if (string.IsNullOrEmpty(SYMBEntry))
				{
					var (INFOOffset, INFOEntry) = bankINFOEntries[(int)i];
					this.SYMBSection.BANKRecord.SetEntry(i, (SYMBOffset, $"SBNK{INFOEntry!.FileID:X4}"));
				}
			}
			wavearcSYMBEntries = this.SYMBSection!.WAVEARCRecord.Entries;
			wavearcINFOEntries = this.INFOSection.WAVEARCRecord.Entries;
			for (uint i = 0, num = (uint)SWARsToKeep.Count; i < num; ++i)
			{
				var (SYMBOffset, SYMBEntry) = wavearcSYMBEntries[(int)i];
				if (string.IsNullOrEmpty(SYMBEntry))
				{
					var (INFOOffset, INFOEntry) = wavearcINFOEntries[(int)i];
					this.SYMBSection.WAVEARCRecord.SetEntry(i, (SYMBOffset, $"SWAR{INFOEntry!.FileID:X4}"));
				}
			}
			playerSYMBEntries = this.SYMBSection!.PLAYERRecord.Entries;
			for (uint i = 0, num = (uint)PLAYERsToKeep.Count; i < num; ++i)
			{
				var (SYMBOffset, SYMBEntry) = playerSYMBEntries[(int)i];
				if (string.IsNullOrEmpty(SYMBEntry))
					this.SYMBSection.PLAYERRecord.SetEntry(i, (SYMBOffset, $"PLAYER{i:X2}"));
			}

			this.SYMBSectionNeedsCleanup = false;
		}

		// Fix the offsets and sizes.
		this.FixOffsetsAndSizes();
	}

	/// <summary>
	/// Fixes the offsets and sizes of the various sections of the <see cref="SDAT" />.
	/// </summary>
	public void FixOffsetsAndSizes()
	{
		// First is updating the offsets and sizes of the SYMB section (if it exists) and INFO section.
		this.INFOOffset = 0x40;
		if (this.SYMBSection is not null)
		{
			this.SYMBOffset = 0x40;
			this.SYMBSize = this.SYMBSection.Size;
			this.SYMBSection.FixOffsets();
			this.INFOOffset = (uint)(this.SYMBOffset + ((this.SYMBSize + 3) & ~0x03));
		}
		this.INFOSize = this.INFOSection.Size;
		this.INFOSection.FixOffsets();
		// Next the FAT section has its number of records set to be the same as the count of SSEQs, SBNKs and SWARs,
		// then updates its offset and size.
		this.FATSection.ResizeRecords((uint)(this.sseqs.Count + this.sbnks.Count + this.swars.Count));
		this.FATOffset = this.INFOOffset + this.INFOSize;
		this.FATSize = this.FATSection.Size;
		// Next the FILE section has its offset and size updated.
		this.FILEOffset = this.FATOffset + this.FATSize;
		uint offset = this.FILEOffset + 0x10;
		this.FILESize = 0x10;
		// Next all the files have their file IDs set and their offsets and sizes corrected in the FAT section.
		uint fileID = 0;
		var fatRecords = this.FATSection.Records;
		var seqEntries = this.INFOSection.SEQRecord.Entries;
		foreach (var sseq in this.sseqs)
		{
			seqEntries[sseq.EntryNumber].Entry!.FileID = fileID;
			var fatRecord = fatRecords[(int)fileID++];
			fatRecord.Offset = offset;
			uint fileSize = sseq.Size;
			fatRecord.Size = fileSize;
			offset += fileSize;
			this.FILESize += fileSize;
		}
		var bankEntries = this.INFOSection.BANKRecord.Entries;
		foreach (var sbnk in this.sbnks)
		{
			sbnk.FixOffsets();
			bankEntries[sbnk.EntryNumber].Entry!.FileID = fileID;
			var fatRecord = fatRecords[(int)fileID++];
			fatRecord.Offset = offset;
			uint fileSize = sbnk.Size;
			fatRecord.Size = fileSize;
			offset += fileSize;
			this.FILESize += fileSize;
		}
		var wavearcEntries = this.INFOSection.WAVEARCRecord.Entries;
		foreach (var swar in this.swars)
		{
			wavearcEntries[swar.EntryNumber].Entry!.FileID = fileID;
			var fatRecord = fatRecords[(int)fileID++];
			fatRecord.Offset = offset;
			uint fileSize = swar.Size;
			fatRecord.Size = fileSize;
			offset += fileSize;
			this.FILESize += fileSize;
		}

		// Finally the size of the entire SDAT is set and the number of blocks is set based on if there is a SYMB section or not.
		this.Size = this.FILEOffset + this.FILESize;
		this.actualBlocks = (ushort)(this.SYMBSection is not null ? 4 : 3);
	}
}
